# Feature 0015: Admin Access Requests Management and User Creation

## Description

Implementare funcționalități pentru administrarea cererilor de acces și crearea utilizatorilor de către admin. Datele din formularul "Request Access" sunt deja salvate în baza de date, dar trebuie să fie accesibile pentru admini printr-o pagină dedicată cu notificări în timp real. De asemenea, adminii trebuie să poată crea utilizatori din pagina Settings.

## Files to Modify

### Backend Files

#### 1. `backend/api/access_requests.py`
- **Modificare**: Înlocuire decorator `@require_auth` cu `@require_admin` pentru endpoint-urile admin
  - Linia 120: `list_access_requests()` - schimbă `@require_auth` în `@require_admin`
  - Linia 181: `get_access_request()` - schimbă `@require_auth` în `@require_admin`
  - Linia 211: `review_access_request()` - schimbă `@require_auth` în `@require_admin`
- **Modificare**: Actualizare `reviewed_by` cu admin ID din request context
  - Linia 251: Înlocuiește TODO cu `access_request.reviewed_by = request.admin_id`
- **Funcții afectate**: `list_access_requests()`, `get_access_request()`, `review_access_request()`

#### 2. `backend/api/admin_users.py`
- **Adăugare**: Endpoint nou pentru crearea utilizatorilor
  - Funcție nouă: `create_user()` - POST `/api/admin/users`
  - Validare: username, email (unic), password (opțional, hash-uit dacă furnizat)
  - Câmpuri opționale: company_name, address, contact_person, phone
  - Setare implicită: `is_admin=False`, `kyc_status='PENDING'`, `risk_level='LOW'`
  - Returnează user creat cu `to_dict(camel_case=True)`
- **Decorator**: Folosește `@require_admin`
- **Validare**: Verifică dacă email-ul există deja înainte de creare
- **Error handling**: Folosește `standard_error_response()` pentru erori consistente

### Frontend Files

#### 3. `src/pages/Settings.tsx`
- **Modificare**: Adăugare tab nou pentru "Access Requests"
  - Linia 46-87: Adăugare Tab nou în Tab.List pentru "Access Requests"
  - Linia 88-98: Adăugare Tab.Panel nou pentru AccessRequestsManagement component
- **Import**: Adăugare import pentru `AccessRequestsManagement` component

#### 4. `src/components/admin/AccessRequestsManagement.tsx` (NEW FILE)
- **Creare**: Component nou pentru gestionarea cererilor de acces
- **Funcționalități**:
  - Listare cereri cu paginare (50 per pagină)
  - Filtrare după status (pending, reviewed, rejected)
  - Căutare după entity sau contact (email)
  - Afișare tabel cu: Entity, Contact, Reference, Status, Created At, Actions
  - Acțiuni: View Details, Review (change status), Add Notes
  - Notificări în timp real pentru cereri noi (polling la fiecare 10 secunde)
  - Badge pentru cereri noi (pending) cu număr de cereri neprocesate
- **State management**:
  - `requests`: Array de AccessRequest
  - `loading`: boolean pentru loading state
  - `error`: string pentru erori
  - `searchTerm`: string pentru căutare
  - `statusFilter`: string pentru filtrare status
  - `selectedRequest`: AccessRequest pentru modal details/review
  - `isDetailsModalOpen`: boolean pentru modal details
  - `isReviewModalOpen`: boolean pentru modal review
  - `newRequestsCount`: number pentru badge notificări
  - `lastCheckedAt`: Date pentru tracking ultima verificare
- **Polling**: useEffect cu setInterval pentru verificare cereri noi la fiecare 10 secunde
  - Compară `created_at` cu `lastCheckedAt` pentru a detecta cereri noi
  - Actualizează `newRequestsCount` și afișează notificare
- **Modals**:
  - Details Modal: Afișează toate detaliile cererii (entity, contact, reference, status, created_at, reviewed_at, reviewed_by, notes)
  - Review Modal: Form pentru schimbare status și adăugare notes
- **UI/UX**:
  - Dark mode support
  - Responsive design
  - Loading states
  - Error handling
  - Success notifications
  - Badge pentru cereri noi în header-ul componentei

#### 5. `src/components/admin/UserManagement.tsx`
- **Modificare**: Adăugare buton "Create User" în header-ul componentei
  - Linia 160-163: Adăugare buton "Create User" lângă titlu
- **Modificare**: Adăugare modal pentru creare utilizator
  - State nou: `isCreateModalOpen`, `createForm`
  - Funcție nouă: `handleCreateUser()` - deschide modal
  - Funcție nouă: `handleSaveCreate()` - salvează utilizator nou
  - Modal nou: Create User Modal cu formular (username, email, password, companyName, address, contactPerson, phone)
  - Validare: Email format, required fields (username, email)
  - Success notification după creare
- **Funcții afectate**: Adăugare funcții noi pentru creare utilizator

#### 6. `src/services/adminService.ts`
- **Adăugare**: Funcție nouă pentru creare utilizator
  - `createUser(data: CreateUserData): Promise<User>`
  - Endpoint: POST `/api/admin/users`
  - Body: `{ username, email, password?, companyName?, address?, contactPerson?, phone? }`
  - Headers: `getAdminHeaders()`
- **Adăugare**: Funcții noi pentru gestionarea cererilor de acces
  - `getAccessRequests(filters?: AccessRequestFilters): Promise<AccessRequestsResponse>`
  - `getAccessRequestDetails(requestId: string): Promise<AccessRequest>`
  - `reviewAccessRequest(requestId: string, data: ReviewData): Promise<AccessRequest>`
- **Adăugare**: Tipuri TypeScript noi
  - `CreateUserData`: `{ username: string, email: string, password?: string, companyName?: string, address?: string, contactPerson?: string, phone?: string }`
  - `AccessRequest`: `{ id: string, entity: string, contact: string, reference?: string, status: string, createdAt: string, reviewedAt?: string, reviewedBy?: string, notes?: string }`
  - `AccessRequestsResponse`: `{ requests: AccessRequest[], total: number, limit: number, offset: number }`
  - `AccessRequestFilters`: `{ status?: string, limit?: number, offset?: number, search?: string }`
  - `ReviewData`: `{ status: string, notes?: string }`

#### 7. `src/i18n/locales/en.ts`, `src/i18n/locales/ro.ts`, `src/i18n/locales/zh.ts`
- **Adăugare**: Chei de traducere pentru Access Requests Management
  - `accessRequests`, `accessRequestsManagement`, `accessRequestsSubtitle`
  - `entity`, `contact`, `reference`, `status`, `createdAt`, `reviewedAt`, `reviewedBy`, `notes`
  - `pending`, `reviewed`, `rejected` (status values)
  - `viewDetails`, `reviewRequest`, `changeStatus`, `addNotes`
  - `newRequests`, `newRequestNotification`, `noNewRequests`
  - `filterByStatus`, `searchRequests`, `noRequestsFound`
  - `requestDetails`, `reviewAccessRequest`, `statusUpdated`, `notesUpdated`
- **Adăugare**: Chei de traducere pentru User Creation
  - `createUser`, `createNewUser`, `userCreatedSuccessfully`
  - `password` (dacă nu există deja), `passwordOptional`

## Implementation Details

### Access Requests Management

**Pagina Access Requests**:
1. **Listare Cereri**:
   - Tabel cu coloane: Entity, Contact, Reference, Status, Created At, Actions
   - Paginare: 50 cereri per pagină
   - Sortare: Descending după `created_at` (cele mai noi primele)
   - Badge status: Color-coded badges pentru pending (yellow), reviewed (blue), rejected (red)

2. **Filtrare și Căutare**:
   - Dropdown pentru filtrare după status (All, Pending, Reviewed, Rejected)
   - Input căutare pentru entity sau contact (email)
   - Filtrele se aplică simultan (AND logic)

3. **Notificări în Timp Real**:
   - Polling la fiecare 10 secunde pentru verificare cereri noi
   - Compară `created_at` cu `lastCheckedAt` pentru a detecta cereri noi
   - Badge în header cu număr de cereri noi (pending)
   - Notificare toast/banner când apare cerere nouă
   - Actualizare automată a listei când apare cerere nouă

4. **Acțiuni**:
   - **View Details**: Modal cu toate detaliile cererii
   - **Review**: Modal pentru schimbare status și adăugare notes
   - Status options: pending, reviewed, rejected
   - Notes field: Textarea pentru note admin (max 1000 chars)

5. **Algoritm Polling**:
   ```
   - La mount: Setează lastCheckedAt = current time
   - La fiecare 10 secunde:
     1. Fetchează toate cererile cu status=pending
     2. Compară created_at cu lastCheckedAt
     3. Dacă există cereri noi:
        - Actualizează newRequestsCount
        - Afișează notificare
        - Actualizează lista
     4. Actualizează lastCheckedAt = current time
   ```

### User Creation in Settings

**Funcționalitate Creare Utilizator**:
1. **Buton Create User**:
   - Poziționat în header-ul componentei UserManagement
   - Deschide modal cu formular

2. **Formular Creare**:
   - Câmpuri obligatorii: Username, Email
   - Câmpuri opționale: Password, Company Name, Address, Contact Person, Phone
   - Validare:
     - Email format validation
     - Email uniqueness check (backend)
     - Username required
   - Password: Dacă nu este furnizat, utilizatorul va trebui să-și seteze parola la primul login (future feature)

3. **Backend Processing**:
   - Hash password dacă este furnizat (folosind werkzeug.security.generate_password_hash)
   - Setare valori implicite: `is_admin=False`, `kyc_status='PENDING'`, `risk_level='LOW'`
   - Generare UUID pentru user ID
   - Setare `created_at` și `updated_at`

4. **Success Flow**:
   - După creare cu succes: Închide modal, afișează success notification, refresh lista utilizatori
   - Utilizatorul nou apare în listă

### Backend API Changes

**Access Requests Endpoints**:
- **GET** `/api/admin/access-requests` - List all access requests (admin only)
  - Query params: `status`, `limit`, `offset`, `search`
  - Response: `{ requests: AccessRequest[], total: number, limit: number, offset: number }`
  - Decorator: `@require_admin` (schimbat din `@require_auth`)

- **GET** `/api/admin/access-requests/<request_id>` - Get specific request (admin only)
  - Response: `AccessRequest` object
  - Decorator: `@require_admin` (schimbat din `@require_auth`)

- **POST** `/api/admin/access-requests/<request_id>/review` - Review request (admin only)
  - Body: `{ status: string, notes?: string }`
  - Updates: `status`, `reviewed_at`, `reviewed_by` (din `request.admin_id`), `notes`
  - Response: Updated `AccessRequest` object
  - Decorator: `@require_admin` (schimbat din `@require_auth`)

**User Creation Endpoint**:
- **POST** `/api/admin/users` - Create new user (admin only)
  - Body: `{ username: string, email: string, password?: string, companyName?: string, address?: string, contactPerson?: string, phone?: string }`
  - Validare: Email format, email uniqueness, username required
  - Processing: Hash password dacă furnizat, setare valori implicite
  - Response: Created `User` object
  - Decorator: `@require_admin`

## Dependencies

- Existing admin authentication system (`@require_admin` decorator)
- Existing AccessRequest model și API endpoints
- Existing User model și admin users API
- Existing admin service (`adminService.ts`)
- Existing translation system (i18n)
- Existing theme system (dark mode)

## Testing Considerations

1. **Access Requests Management**:
   - Verificare listare cereri cu paginare
   - Verificare filtrare după status
   - Verificare căutare după entity/contact
   - Verificare polling pentru cereri noi (simulare cerere nouă)
   - Verificare notificări pentru cereri noi
   - Verificare review cerere (schimbare status, adăugare notes)
   - Verificare dark mode și responsive design

2. **User Creation**:
   - Verificare creare utilizator cu toate câmpurile
   - Verificare creare utilizator cu câmpuri minime (username, email)
   - Verificare validare email format
   - Verificare validare email uniqueness
   - Verificare hash password
   - Verificare valori implicite setate corect
   - Verificare success notification și refresh listă

3. **Security**:
   - Verificare că doar adminii pot accesa endpoint-urile
   - Verificare că doar adminii pot crea utilizatori
   - Verificare validare input pe backend
   - Verificare SQL injection protection (ORM)

## Notes

- Datele din formularul "Request Access" sunt deja salvate în baza de date prin endpoint-ul existent `POST /api/access-requests`
- Endpoint-urile admin pentru access requests folosesc acum `@require_admin` în loc de `@require_auth` pentru consistență
- Polling pentru notificări în timp real folosește interval de 10 secunde (configurabil dacă este necesar)
- Crearea utilizatorilor permite password opțional - dacă nu este furnizat, utilizatorul va trebui să-și seteze parola la primul login (feature viitor)
- Toate endpoint-urile folosesc `standard_error_response()` pentru erori consistente
- Toate răspunsurile API folosesc camelCase format pentru frontend compatibility

